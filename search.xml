<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C/C++字符串操作]]></title>
    <url>%2FC%E4%B8%8EC%2B%2B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[一、 C++字符串操作头文件#include&lt;string&gt; using std::string 1、 构造函数1234567891011121314151617181920212223default (1)string();copy (2)string (const string&amp; str);substring (3)string (const string&amp; str, size_t pos, size_t len = npos);from c-string (4)string (const char* s);from buffer (5)string (const char* s, size_t n);fill (6)string (size_t n, char c); 2、 常用函数1234567891011121314151617string str = "copy"; char *ch = "chars"; //1 constructor string str1;//default (1) string(); string str2(str); //copy (2) string (const string&amp; str); string str3("hello",1,2);//substring (3) string (const string&amp; str, size_t pos,size_t len = npos); string str4(ch);//from c-string (4) string(const char* s); string str5(ch, 2); //from buffer (5) string(const char* s, size_t n); string str6(10, 'c');// fill(6) string(size_tn, char c); C++官网函数介绍 介绍几个常用的1）c_str123456789101112131415161718192021222324// strings and c-strings//补充strtok知识：//函数原型：char *strtok(char *s,const char *delim)//函数功能：分解字符串为一组字符串，s为要分解的字符串，delim为分隔字//符串#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;int main ()&#123; std::string str ("Please split this sentence into tokens"); char * cstr = new char [str.length()+1]; std::strcpy (cstr, str.c_str()); // cstr now contains a c-string copy of str char * p = std::strtok (cstr," "); while (p!=0) &#123; std::cout &lt;&lt; p &lt;&lt; '\n'; p = std::strtok(NULL," "); &#125; delete[] cstr; getchar(); return 0;&#125; 输出打印： 123456Please split this sentence into tokens 2）data1234567891011121314151617181920212223242526272829// string::data//补充：C 库函数： //int memcmp(const void *str1, const void *str2, size_t n))//把存储区 str1 和存储区 str2 的前 n 个字节进行 //如果返回值 &lt; 0，则表示 str1 小于 str2。//如果返回值 &gt; 0，则表示 str2 小于 str1。//如果返回值 = 0，则表示 str1 等于 str2。 #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;int main ()&#123; int length; std::string str = "Test string"; char* cstr = "Test string"; if ( str.length() == std::strlen(cstr) ) &#123; std::cout &lt;&lt; "str and cstr have the same length.\n"; if ( memcmp (cstr, str.data(), str.length() ) == 0 ) std::cout &lt;&lt; "str and cstr have the same content.\n"; &#125; return 0;&#125; Output: 12str and cstr have the same length.str and cstr have the same content. 3）copy()123456789101112131415161718192021222324//size_t copy (char* s, size_t len, size_tpos = 0) const;//s: 指向要复制到的字符数组指针，目标字符数组//len：需要复制的长度//pos: 复制的起始位置 // string::copy#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; char buffer[20]; std::string str ("Teststring..."); std::size_t length = str.copy(buffer,6,5); buffer[length]='\0'; std::cout &lt;&lt; "buffercontains: " &lt;&lt; buffer&lt;&lt; '\n'; return 0;&#125; 输出： 1buffer contains: string 4）find123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//string (1)//size_t find (const string&amp; str, size_t pos = 0) const noexcept;//c-string (2)//size_t find (const char* s, size_t pos = 0) const;//buffer (3)//size_t find (const char* s, size_t pos, size_type n) const;//character (4)//size_t find (char c, size_t pos = 0) const noexcept;//str:需要查找的目标字符串//pos:查找起始位置//s:指向要查找字符数组的指针//n:要查找的字符数组的长度//c:要查找的单个字符//返回：The position of the first characterof the first match.//If no matches were found, the function returns string::npos.// string::find#include &lt;iostream&gt; // std::cout#include &lt;string&gt; // std::stringint main ()&#123; std::string str ("Thereare two needles in this haystack with needles."); std::string str2 ("needle"); // different member versions of find in thesame order as above: std::size_t found = str.find(str2); if (found!=std::string::npos) std::cout &lt;&lt; "first'needle' found at: "&lt;&lt; found &lt;&lt; '\n'; found=str.find("needlesare small",found+1,6); if (found!=std::string::npos) std::cout &lt;&lt; "second'needle' found at: "&lt;&lt; found &lt;&lt; '\n'; found=str.find("haystack"); if (found!=std::string::npos) std::cout &lt;&lt; "'haystack'also found at: "&lt;&lt; found &lt;&lt; '\n'; found=str.find('.'); if (found!=std::string::npos) std::cout &lt;&lt; "Periodfound at: " &lt;&lt; found&lt;&lt; '\n'; // let's replace the first needle: str.replace(str.find(str2),str2.length(),"preposition"); std::cout &lt;&lt; str &lt;&lt; '\n'; return 0;&#125; 输出： 12345first &apos;needle&apos; found at: 14second &apos;needle&apos; found at: 44&apos;haystack&apos; also found at: 30Period found at: 51There are two prepositions in this haystack with needles. 5) find first of12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//string (1)//size_t find_first_of (const string&amp; str, size_t pos = 0) const noexcept;//c-string(2)//size_t find_first_of (const char* s, size_t pos = 0) const;//buffer (3)//size_t find_first_of (const char* s, size_t pos, size_t n) const;//character (4)//size_t find_first_of (char c, size_t pos = 0) const noexcept;//参数：//Str 需要查找的目标字符//Pos 查找的起始位置//S 指向字符数组的指针//N 需要查找的字符个数//C 需要查找的单个字符//返回：返回匹配到的第一个字符的索引号.//size_t is an unsigned integral type (the sameas member type string::size_type).#include &lt;iostream&gt; // std::cout#include &lt;string&gt; // std::string#include &lt;cstddef&gt; // std::size_tint main ()&#123; std::string str ("Please, replace the vowels in this sentence by asterisks."); std::size_t found = str.find_first_of("aeiou"); while (found!=std::string::npos) &#123; str[found]='*'; found=str.find_first_of("aeiou",found+1); &#125; std::cout &lt;&lt; str &lt;&lt; '\n'; return 0;&#125; 注意该函数与find的区别：如果str1中含有str2中的任何字符，则就会查找成功，而find则不同。 6)find_last_of123456789101112131415161718192021222324252627282930313233343536373839404142//string (1)//size_t find_last_of (const string&amp; str, size_t pos = 0) const noexcept;//c-string(2)//size_t find_last_of (const char* s, size_t pos = 0) const;//buffer (3)//size_t find_last_of (const char* s, size_t pos, size_t n) const;//character (4)//size_t find_last_of (char c, size_t pos = 0) const noexcept;//该函数参数与find_first_of 基本一致，顾名思义返回的是查找到与目标字符最后一个匹配成功的索引。// string::find_last_of#include &lt;iostream&gt; // std::cout#include &lt;string&gt; // std::string#include &lt;cstddef&gt; // std::size_t//分割字符串，路径与文件名的分割void SplitFilename (const std::string&amp; str, std::string splittext )&#123; std::cout &lt;&lt; "Splitting: " &lt;&lt; str &lt;&lt; '\n'; std::size_t found = str.find_last_of(splittext); std::cout &lt;&lt; " path: " &lt;&lt; str.substr(0,found) &lt;&lt; '\n'; std::cout &lt;&lt; " file: " &lt;&lt; str.substr(found+1) &lt;&lt; '\n';&#125;int main ()&#123; std::string str1 ("/usr/bin/man","/\\"); std::string str2 ("c:\\windows\\winhelp.exe","/\\"); SplitFilename (str1); SplitFilename (str2); return 0;&#125; 输出： 1234567891011Splitting: /usr/bin/man path:/usr/bin file:manSplitting: c:\windows\winhelp.exe path:c:\windows file:winhelp.exe 7）std::string::substr123456789101112131415161718//string substr (size_t pos = 0, size_t len = npos) const;//参数：//Pos 子串在字符串的其实位置//Len 子串的长度，字符个数 默认为以pos为起始的剩下所有字符//返回：该函数返回字符串的子串// string::substr#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string str="We think in generalities, but we live in details."; // (quoting Alfred N. Whitehead) std::string str2 = str.substr (3,5); // "think" std::size_t pos = str.find("live"); // position of "live" in str std::string str3 = str.substr (pos); // get from "live" to the end std::cout &lt;&lt; str2 &lt;&lt; ' ' &lt;&lt; str3 &lt;&lt; '\n'; return 0;&#125; 7）std::string::compare123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//string (1)//int compare (const string&amp; str) const noexcept;//substrings (2)//int compare (size_t pos, size_t len, const string&amp; str) const;//int compare (size_t pos, size_t len, const string&amp; str,// size_t subpos, size_t sublen) const;//c-string (3)//int compare (const char* s) const;//int compare (size_t pos, size_t len, const char* s) const;//buffer (4)//int compare (size_t pos, size_t len, const char* s, size_t n) const;//Str 需要比较的目标字符串//Pos 字符串起始位置，该起始位置为待比较的字符串//Len 待比较的字符串相对Pos的长度（单位：单个字符）//subpos,sublen 参数中字符串的起始位置以及长度//s 指向字符数组的指针//n 需要比较的字符的个数// comparing apples with apples#include &lt;iostream&gt;#include &lt;string&gt;int main ()&#123; std::string str1 ("green apple"); std::string str2 ("red apple"); if (str1.compare(str2) != 0) std::cout &lt;&lt; str1 &lt;&lt; " is not " &lt;&lt; str2 &lt;&lt; '\n'; if (str1.compare(6,5,"apple") == 0) std::cout &lt;&lt; "still, " &lt;&lt; str1 &lt;&lt; " is an apple\n"; if (str2.compare(str2.size()-5,5,"apple") == 0) std::cout &lt;&lt; "and " &lt;&lt; str2 &lt;&lt; " is also an apple\n"; if (str1.compare(6,5,str2,4,5) == 0) std::cout &lt;&lt; "therefore, both are apples\n"; return 0;&#125; 输出; 1234green apple is not red applestill, green apple is an appleand red apple is also an appletherefore, both are apples 2、C语言字符串操作1）字符串操作 strcpy(p, p1) 复制字符串 strncpy(p, p1, n) 复制指定长度字符串 strcat(p, p1) 附加字符串 strncat(p, p1, n) 附加指定长度字符串 strlen(p) 取字符串长度 strcmp(p, p1) 比较字符串 strcasecmp忽略大小写比较字符串 strncmp(p, p1, n) 比较指定长度字符串 strchr(p, c) 在字符串中查找指定字符 strrchr(p, c) 在字符串中反向查找 strstr(p, p1) 查找字符串 strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素 strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移 strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移 * 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 2）字符串到数值类型的转换 strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型atoi(p) 字符串转换到 int 整型atof(p) 字符串转换到 double 符点数atol(p) 字符串转换到 long 整型 3）字符检查 isalpha() 检查是否为字母字符isupper() 检查是否为大写字母字符islower() 检查是否为小写字母字符isdigit() 检查是否为数字isxdigit() 检查是否为十六进制数字表示的有效字符isspace() 检查是否为空格类型字符iscntrl() 检查是否为控制字符ispunct() 检查是否为标点符号isalnum() 检查是否为字母和数字isprint() 检查是否是可打印字符isgraph() 检查是否是图形字符，等效于 isalnum() | ispunct() 4）函数原型原型：strcpy(char destination[], const char source[]); 功能：将字符串source拷贝到字符串destination中例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[10] = &#123; "TsinghuaOK"&#125;; char str2[10] = &#123; "Computer"&#125;; cout &lt;&lt;strcpy(str1,str2)&lt;&lt;endl; &#125; 运行结果是:Computer第二个字符串将覆盖掉第一个字符串的所有内容！注意：在定义数组时，字符数组1的字符串长度必须大于或等于字符串2的字符串长度。不能用赋值语句将一个字符串常量或字符数组直接赋给一个字符数组。所有字符串处理函数都包含在头文件string.h中。 strncpy(char destination[], const char source[], int numchars); strncpy：将字符串source中前numchars个字符拷贝到字符串destination中。strncpy函数应用举例原型：strncpy(char destination[], const char source[], int numchars);功能：将字符串source中前numchars个字符拷贝到字符串destination中例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[10] = &#123; "Tsinghua "&#125;; char str2[10] = &#123; "Computer"&#125;; cout &lt;&lt;strncpy(str1,str2,3)&lt;&lt;endl; &#125; 运行结果：Comnghua注意：字符串source中前numchars个字符将覆盖掉字符串destination中前numchars个字符！ 原型：strcat(char target[], const char source[]); 功能：将字符串source接到字符串target的后面例程：#include #include void main(void){ char str1[] = { “Tsinghua “}; char str2[] = { “Computer”}; cout &lt;&lt;strcpy(str1,str2)&lt;&lt;endl;} 运行结果：Tsinghua Computer 注意：在定义字符数组1的长度时应该考虑字符数组2的长度，因为连接后新字符串的长度为两个字符串长度之和。进行字符串连接后，字符串1的结尾符将自动被去掉，在结尾串末尾保留新字符串后面一个结尾符。 原型：strncat(char target[], const char source[], int numchars); 功能：将字符串source的前numchars个字符接到字符串target的后面例程： 12345678#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str1[] = &#123; &quot;Tsinghua &quot;&#125;; char str2[] = &#123; &quot;Computer&quot;&#125;; cout &lt;&lt;strncat(str1,str2,3)&lt;&lt;endl; &#125; 运行结果：Tsinghua Com 原型：int strcmp(const char firststring[], const char secondstring); 功能：比较两个字符串firststring和secondstring例程： 12345678910111213141516171819#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char buf1[] = &quot;aaa&quot;; char buf2[] = &quot;bbb&quot;; char buf3[] = &quot;ccc&quot;; int ptr; ptr = strcmp(buf2,buf1); if(ptr &gt; 0) cout &lt;&lt;&quot;Buffer 2 is greater than buffer 1&quot;&lt;&lt;endl; else cout &lt;&lt;&quot;Buffer 2 is less than buffer 1&quot;&lt;&lt;endl; ptr = strcmp(buf2,buf3); if(ptr &gt; 0) cout &lt;&lt;&quot;Buffer 2 is greater than buffer 3&quot;&lt;&lt;endl; else cout &lt;&lt;&quot;Buffer 2 is less than buffer 3&quot;&lt;&lt;endl; &#125; 运行结果是: 12Buffer 2 is less than buffer 1 Buffer 2 is greater than buffer 3 原型：strlen( const char string[] ); 功能：统计字符串string中字符的个数例程： 123456789#include &lt;iostream.h&gt; #include &lt;string.h&gt; void main(void) &#123; char str[100]; cout &lt;&lt;&quot;请输入一个字符串:&quot;; cin &gt;&gt;str; cout &lt;&lt;&quot;The length of the string is :&quot;&lt;&lt;strlen(str)&lt;&lt;&quot;个&quot;&lt;&lt;endl; &#125; 运行结果The length of the string is x (x为你输入的字符总数字) 注意：strlen函数的功能是计算字符串的实际长度，不包括’\0’在内。另外，strlen函数也可以直接测试字符串常量的长度，如：strlen(“Welcome”)。 void *memset(void *dest, int c, size_t count); 将dest前面count个字符置为字符c. 返回dest的值. void *memmove(void dest, const void src, size_t count); 从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理. 返回dest的值. void *memcpy(void dest, const void src, size_t count); 从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠. 返回dest的值. void *memchr(const void *buf, int c, size_t count); 在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回NULL. void _memccpy(void dest, const void *src, int c, size_t count);从src复制0个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止. 如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回NULL. int memcmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2前面count个字节大小.返回值&lt; 0, 表示buf1小于buf2;返回值为0, 表示buf1等于buf2;返回值&gt; 0, 表示buf1大于buf2. int memicmp(const void *buf1, const void *buf2, size_t count); 比较buf1和buf2前面count个字节. 与memcmp不同的是, 它不区分大小写. 返回值同上. char *strrev(char *string); 将字符串string中的字符顺序颠倒过来. NULL结束符位置不变. 返回调整后的字符串的指针. char *_strupr(char *string); 将string中所有小写字母替换成相应的大写字母, 其它字符保持不变. 返回调整后的字符串的指针. char *_strlwr(char *string); 将string中所有大写字母替换成相应的小写字母, 其它字符保持不变. 返回调整后的字符串的指针. char *strchr(const char *string, int c); 查找字 串string中首次出现的位置, NULL结束符也包含在查找中. 返回一个指针, 指向字符c在字符串string中首次出现的位置, 如果没有找到, 则返回NULL. char *strrchr(const char *string, int c); 查找字符c在字符串string中最后一次出现的位置, 也就是对string进行反序搜索, 包含NULL结束符.返回一个指针, 指向字符c在字符串string中最后一次出现的位置, 如果没有找到, 则返回NULL. char *strstr(const char string, const char strSearch); 在字符串string中查找strSearch子串. 返回子串strSearch在string中首次出现位置的指针. 如果没有找到子串strSearch, 则返回NULL. 如果子串strSearch为空串, 函数返回string值. char *strdup(const char *strSource); 函数运行中会自己调用malloc函数为复制strSource字符串分配存储空间, 然后再将strSource复制到分配到的空间中. 注意要及时释放这个分配的空间.返回一个指针, 指向为复制字符串分配的空间; 如果分配空间失败, 则返回NULL值. char *strcat(char strDestination, const char strSource); 将源串strSource添加到目标串strDestination后面, 并在得到的新串后面加上NULL结束符. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 在字符串的复制或添加过程中没有溢出检查, 所以要保证目标串空间足够大. 不能处理源串与目标串重叠的情况. 函数返回strDestination值. char *strncat(char strDestination, const char strSource, size_t count); 将源串strSource开始的count个字符添加到目标串strDest后. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 如果count大于源串长度, 则会用源串的长度值替换count值. 得到的新串后面会自动加上NULL结束符. 与strcat函数一样, 本函数不能处理源串与目标串重叠的情况. 函数返回strDestination值. char *strcpy(char strDestination, const char strSource); 复制源串strSource到目标串strDestination所指定的位置, 包含NULL结束符. 不能处理源串与目标串重叠的情况.函数返回strDestination值. char *strncpy(char strDestination, const char strSource, size_t count);将源串strSource开始的count个字符复制到目标串strDestination所指定的位置. 如果count值小于或等于strSource串的长度, 不会自动添加NULL结束符目标串中, 而count大于strSource串的长度时, 则将strSource用NULL结束符填充补齐count个字符, 复制到目标串中. 不能处理源串与目标串重叠的情况.函数返回strDestination值. char *strset(char *string, int c); 将string串的所有字符设置为字符c, 遇到NULL结束符停止. 函数返回内容调整后的string指针. char *strnset(char *string, int c, size_t count); 将string串开始count个字符设置为字符c, 如果count值大于string串的长度, 将用string的长度替换count值. 函数返回内容调整后的string指针. size_t strspn(const char *string, const char *strCharSet); 查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置序号. 返回一个整数值, 指定在string中全部由characters中的字符组成的子串的长度. 如果string以一个不包含在strCharSet中的字符开头, 函数将返回0值. size_t strcspn(const char *string, const char *strCharSet); 查找strCharSet串中任何一个字符在string串中首次出现的位置序号, 包含字符串结束符NULL.返回一个整数值, 指定在string中全部由非characters中的字符组成的子串的长度. 如果string以一个包含在strCharSet中的字符开头, 函数将返回0值. char *strspnp(const char string, const char strCharSet); 查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置指针. 返回一个指针, 指向非strCharSet中的字符在string中首次出现的位置. char *strpbrk(const char string, const char strCharSet);查找strCharSet串中任何一个字符在string串中首次出现的位置, 不包含字符串结束符NULL.返回一个指针, 指向strCharSet中任一字符在string中首次出现的位置. 如果两个字符串参数不含相同字符, 则返回NULL值. int strcmp(const char *string1, const char *string2); 比较字符串string1和string2大小.返回值&lt; 0, 表示string1小于string2;返回值为0, 表示string1等于string2;返回值&gt; 0, 表示string1大于string2. int stricmp(const char *string1, const char *string2); 比较字符串string1和string2大小，和strcmp不同, 比较的是它们的小写字母版本.返回值与strcmp相同. int strcmpi(const char *string1, const char *string2); 等价于stricmp函数, 只是提供一个向后兼容的版本. int strncmp(const char *string1, const char *string2, size_t count); 比较字符串string1和string2大小，只比较前面count个字符. 比较过程中, 任何一个字符串的长度小于count, 则count将被较短的字符串的长度取代. 此时如果两串前面的字符都相等, 则较短的串要小.返回值&lt; 0, 表示string1的子串小于string2的子串;返回值为0, 表示string1的子串等于string2的子串;返回值&gt; 0, 表示string1的子串大于string2的子串. int strnicmp(const char *string1, const char *string2, size_t count); 比较字符串string1和string2大小，只比较前面count个字符. 与strncmp不同的是, 比较的是它们的小写字母版本. 返回值与strncmp相同. char *strtok(char strToken, const char strDelimit); 在strToken 串中查找下一个标记, strDelimit字符集则指定了在当前查找调用中可能遇到的分界符. 返回一个指针, 指向在strToken中找到的下一个标记. 如果找不到标记, 就返回NULL值. 每次调用都会修改strToken内容, 用NULL字符替换遇到的每个分界符.]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度探索C++对象模型]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[​ C++在布局以及存取时间上主要的额外负担是由virtual引起，包括：virtual function 和 virtual base class 1.1 c++对象模式​ C++中有两种类数据成员：static和nonstatic，以及三种类成员函数：static、nonstatic、virtual。 ​ 简单对象模型：成员本身不存放在object中，只有指向成员的指针存放在object中。object的成员是以slot的索引值来寻址。 ​ 表格驱动模型：将所有与成员相关的信息抽象出来，放在一个data member table和一个member function table之中，class object本身则含有指向这两个表格的指针。member function table是一系列的slots，每个slot指出一个member function，data member table 则直接含有data本身。该模型并没有直接应用到编译器当中，但该观念却成为支持virtual function的一个有效方案。 ​ C++对象模型：Nonstatic data members被配置于每一个class object之内，static data members则被存放在所有的class object之外，static 和Nonstatic function members也被存放在所有的class object 之外。virtual function则以两个步骤支持：1、每一个class产生一堆指向virtual function的指针，放在表格中，该表格称为virtual table；2、每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针称为vptr，vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object也经由virtual table被指出了，通常被放在表格的第一个slot处。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习之路--1、绪论]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-1%E3%80%81%E7%BB%AA%E8%AE%BA.html</url>
    <content type="text"><![CDATA[该博客为数据结构与算法课程的学习笔记！ (a) 计算计算 = 信息处理：借助某种工具，遵照一定的规则，以明确而机械的方式进行。 计算模型 = 计算机 = 信息处理工具 算法： 即在特定的计算模型下，旨在解决特定问题的指令序列。 正确性：的确可以解决的问题。 确定性：任意算法都可以描述成一个由基本操作组成的序列。 可行性：每一基本操作都可以实现，且在常数时间内完成。 有穷性：对于任意输入，经有穷次基本操作都可以得到输出。 (b) 计算模型T(n) : 用算法A求解某一问题规模为n的实例所需的计算成本 T(n)=max [T(p)| |p|=n)]​ 亦即：在规模同为n的所有实例中，只关注最坏（成本最高）者。 T(n)=算法为解决规模为n的问题所需的基本操作次数。 (c) 大o记号 T(n) =o(f(n))f(n)相对于T(n)更加简洁，但依旧可以反映后者的增长趋势。f(n)常系数可以忽略，低次项可以忽略。 $o(1)$=任意常数: 此类算法效率最高，是对数据结构的基本操作，其代码一定满足以下： 一定不含循环 一定不含分支转向 一定不能有递归调用 对数复杂度$o(log n)$: 其值与常底数无关、与常数次幂无关，此类算法非常有效，复杂度无限接近常数。有序向量的二分查找 堆、词典的查询、插入与删除。 多项式复杂度$o(n^c)$：此类算法的效率通常认为已可令人满意。其中：线性复杂度o(n)属于努力的目标，如树图的遍历；平方复杂度存在于所有输入对象两两组合，如Dijkstra算法；立方复杂度不常见，如矩阵乘法。 ​ $o(n log^*n)$几乎接近线性,某些MST算法。 ​ $o(nlogn)$最常出现，但未必最优，排序，EU，Huffman算法。 指数复杂度$o(2^n)$:此类算法计算成本增长极快，通常被认为不可接受。最平凡的算法，需要尽可能的优化。 从$o(n^c)$到$o(2^n)$，是从有效算法到无效算法的分水岭。 对于绝大多数问题，并不存在算法！！！ (d)算法分析算法分析的主要任务分为：正确性（不变性x单调性） + 复杂度 C++等高级语言的基本指令均等效于常数条RAM的基本指令，在渐进意义下，二者大体相当。 复杂度分析的方法： ​ 迭代：级数求和 ​ 递归：递归跟踪+递推方程 ​ 猜测+验证 级数： 对于算术级数，复杂度与末项平方同阶：$T(n)=1+2+3+···+n=n(n+1)/2=o(n^2)$ 对于幂次级数，复杂度比幂次高出一阶：$T(n)=\sum k^n=\int k^ndn=o(k^(n+1))$ 对于几何级数（a&gt;1），复杂度与末项同阶：$T(n)=\sum_{i=0}^{i=n} a^i=o(a^n)$ (e)递归与迭代 数组求和之线性递归： 1234567int sum(int A[],int n) //计算数组中n个数的和&#123; if (n&lt;1)&#123; return 0;&#125; else &#123; return A[n-1]+sum(A,n-1); &#125; &#125; 数组求和之二分递归： 123456int sum(int A[],int a ,int b)&#123; if(a==b) return A[a]; int mid=(a+b)/2; return (sum(A,a,mid)+sum(A,mid+1,b));&#125; (f)局限RAM模型：常数代价准则、对数代价准则 循环移位： 12345void shift(int *A,int n,int k)&#123; reverse(A,k); reverse(A+k,n-k); reverse(A,n);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt程序打包]]></title>
    <url>%2FQt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85.html</url>
    <content type="text"><![CDATA[此处提供一种简单的方法将Qt中的程序打包出来到别的电脑运行： 提取出.exe文件至一个新的目录下 使用qt Desktop，运行命令行：（注意空格） 12$ cd /d 放置.exe文件的新目录地址$ windeployqt 文件名.exe]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT　</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT框架下C++调用matlab混合编程]]></title>
    <url>%2FQT%E6%A1%86%E6%9E%B6%E4%B8%8BC%2B%2B%E8%B0%83%E7%94%A8matlab%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[在visual studio下调用MATLAB程序比较简单，但是在QT框架下用C++调用matlab复杂许多，网上诸多博客不够具体详细，这里结合我的实际过程以及相关博客，给读者分享一下QT调用MATLAB程序进行混合编程的基本流程。 编译DLL文件作为例子，我先编写了一个简单的相加函数add_matlab.m，代码如下： 123function [p]=add_matlab(a,b)p=a+b;end 保存之后，开始编译成DLL文件。 注意： 要想成功编译成DLL文件，首先你的MATLAB得是成功破解的版本，否则会出现报错:Test checkout of feature &#39;Compiler&#39; failed。 需要配置MATLAB编译环境，在MATLAB命令行窗口下输入mbuild -setup,如下图： 点击C++的选项进行安装。如果未出现上述信息，而是显示未找到支持的编译器或SDK，则需要安装对应的编译器，要注意MATLAB安装的编译器必须和你的QT的编译器一个类型，绝对不要QT是MinGW编译器，而MATLAB是MSVC编译器，一定要一致。 安装编译器后在命令行窗口中输入mex -setup C++ ,如果没有报错即安装成功。 在命令行输入deploytool,如下图： 选择Library Compile，如下图： 在TYPE栏选择C++ shared Library，在EXPORTED FUNCTIONS添加要编译的.m文件，本文以上述所写的add_matlab.m为例，点击右上角绿色的Package，即可产生DLL文件，文件夹如下图： for_testing 目录下是用于测试的，但是dll不是可执行文件，不能直接进行进行测试。 for_redistribution目录下是文件MyAppInstaller_web.exe，这个是MATLAB运行时库的和本项目的安装文件，运行后可从网上下载MATLAB的运行时库进行安装，还会安装本项目生成的DLL、LIB和h文件。 此处我们选择第二个文件夹，我们将要使用的是其中的.h、.lib、.dll文件。 QT调用add_matlab.dll首先我们创建一个QtWidget Application项目test_dll，界面如下 实现从文本框输入两个数值之后，qdebug出相加的结果。 添加.lib库在项目目录下新建一个include目录，将前面编译生成的add_matlab\for_redistribution_files_only目录下的add_matlab.lib和add_matlab.h、add_matlab.dll文件复制到此目录下。 在Qt Creator里，项目节点上单击右键，选择“Add Library...”，在出现的向导中首先选择“External Library”，后续出现下图的界面，选择库test_dll\include\目录下的库文件add_matlab.Lib，其他选择如图。 在此对话框完成后，在test_dll.pro文件中会增加如下的几行： 1234win32: LIBS += -L$$PWD/include/ -ladd_matlabINCLUDEPATH += $$PWD/includeDEPENDPATH += $$PWD/include 添加Matlab其他依赖库和头文件搜索路径除了自己编译生成的DLL相关的.lib文件和头文件，要编译此Qt项目，还需要用到MATLAB的几个.lib文件和.h文件。 1234567891011121314# 用到的MATLAB 的.lib库文件 及其搜索路径win32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -llibmxwin32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -llibmatwin32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -llibengwin32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -lmclmcrwin32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -lmclmcrrtwin32: LIBS += -LC:/Matlab/v94/extern/lib/win64/microsoft/ -llibmexINCLUDEPATH += C:/Matlab/v94/extern/lib/win64/microsoftDEPENDPATH += C:/Matlab/v94/extern/lib/win64/microsoft# .h文件搜索路径INCLUDEPATH += C:/MATLAB/v94/extern/includeINCLUDEPATH += C:/MATLAB/v94/extern/include/win64 此处路径为MATLAB安装路径，按照你的安装路径相应修改，要注意MATLAB安装路径不要带有空格（如Program Files），否则会被视为两行。 add_matlab.dll文件要复制到项目编译后的debug目录下。 QT编译将add_matlab.h文件添加进项目中，并且在MainWidget.h文件中引用，随后使用add_matlab函数代码，如下图： add_matlabInitialize()为初始化函数，一定要记得添加。 QT中使用mwArray类型数组作为MATLAB编译函数的输入输出数据接口， 1mwArray matrixA(rowCnt,colCnt,mxDOUBLE_CLASS, mxREAL); 此外add_matlab函数第一个参数int nargout是输出参数个数，表示后面紧跟着的nargout个变量是输出参数 1extern LIB_add_matlab_CPP_API void MW_CALL_CONV add_matlab(int nargout, mwArray&amp; C, const mwArray&amp; A, const mwArray&amp; B); 编译运行之后，结果如下图：]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next主题配置]]></title>
    <url>%2FHexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[1、 站点配置文件_config.yml站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，例如我保存的博客目录为F:\myblog，那么我站点配置文件为F:\myblog\ _config.yml，我使用的主题是Next主题，所以我的主题配置文件为F:\myblog\themes\next\ _config.yml。 你可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含你网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 如果你的网站存放在子目录中，例如 http://yoursite.com/blog，则请将你的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 未完待续。。。。。。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github Page搭建个人博客]]></title>
    <url>%2FHexo-Github-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[之前看到很多人搭建自己的博客，而不是依托于CSDN、博客园等站点，因此课后之余，花了点时间搭建了本博客，期间遇到了很多问题，现在再此写下了具体的搭建过程以及遇到的麻烦和具体的解决办法，希望对读者有所帮助。 1、Hexo1.1 Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.2 安装前提安装Hexo前需要安装Node.js和Git。 安装Git Windows：下载并安装 git. Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 注意：初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 1234&gt; $ git config --global user.name &quot;Your name&quot;&gt; &gt; $ git config --global user.email &quot;Your email&quot;&gt; &gt; 此外，初次使用git的用户要使用git协议大概需要三个步骤： 一、生成密钥对 12&gt; $ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;&gt; &gt; 二、设置远程仓库（本文以github为例）上的公钥 12345&gt; 1.查看生成的公钥: $ cat ~/.ssh/id_rsa.pub &gt; 2.随后登陆你的GitHub账户，Setting-&gt;左栏点击SSH and GPG keys-&gt;New SSH key&gt; 3.复制上面所查看的公钥，粘贴进key文本域，点击Add key&gt; 4.验证是否起作用: $ ssh -T git@github.com &gt; &gt; 三、把git的 remote url 修改为git协议 12&gt; $ git remote set-url origin git@github.com:someaccount/someproject.git&gt; 安装Node.js对于windows用户来说，建议使用 安装程序 进行安装。安装时，请勾选Add to PATH选项。 1.3 安装Hexo所有必备的应用程序安装完成后，即可使用 npm安装 Hexo。 1$ npm install -g hexo-cli 该命令行在Git Bash 上使用，打开它的方法很简单，在桌面或者文件夹任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，读者可以考虑始终使用Git Bash来进行操作。 2、搭建博客2.1 初始化安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 当然你也可以自己新建一个目录，比如我在F盘中创建了myblog目录，进入目录中点击右键选择Git Bash Here，直接执行以下命令 12$ hexo init $ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 2.2 启动服务器执行以下命令来启动服务： 12$ hexo g #hexo generate，生成静态文件$ hexo s #hexo server，启动本地服务器 如果启动过程中没有报错，此时你用浏览器访问http://localhost:4000/，就可以看到一个空白的博客页面，hexo3.0使用的默认主题是landscape，此时的服务是本地启动的，别人并不能看到。 2.3 Github配置想要别人也访问到你的页面，跟着继续吧。首先在Github官网上注册一个账号，有账号的跳过注册，直接登录。登录后找到new repository按钮创建一个新的仓库, 要注意必须创建与你的Github用户名相对应的Github Page仓库，格式必须是username.github.io。 2.3 建立关联进入你刚创建的仓库，复制仓库的地址 ,然后打开hexo文件夹下的_config.yml文件，拉倒最下面，修改deploy为以下代码，在repository后面粘贴你的仓库地址： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 输入以下命令部署到Github Page 123$ hexo clean$ hexo g$ hexo d 然后在浏览器输入username.github.io就可以看到你的博客啦。 之后每次更改你的_post目录下的博客文章，都需要输入上述命令来部署到Github Page。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github page</tag>
      </tags>
  </entry>
</search>
